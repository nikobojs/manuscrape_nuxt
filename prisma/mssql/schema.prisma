generator client {
  provider = "prisma-client-js"
  output   = "../../node_modules/@prisma-mssql/client"
}

datasource db {
  provider = "sqlserver"
  url      = env("MSSQL_DATABASE_URL")
}

model User {
  id                           Int                    @id @default(autoincrement())
  email                        String                 @unique
  password                     String
  createdAt                    DateTime               @default(now())
  observations                 Observation[]
  ownedProjects                Project[]              @relation("author")
  projectAccess                ProjectAccess[]        @relation("contributor")
  sentInvitations              ProjectInvitation[]    @relation("inviter")
  projectExports               ProjectExport[]            
}

// TODO: make sure this is deleted correctly on MSSQL on project deletion
model ProjectAccess {
  createdAt                    DateTime               @default(now())
  role                         String                 @default(value: "OWNER")
  nameInProject                String
  userId                       Int
  projectId                    Int
  user                         User                   @relation("contributor", fields: [userId], references: [id], onDelete: Cascade)
  project                      Project                @relation(fields: [projectId], references: [id], onDelete: NoAction, onUpdate: NoAction)

  @@id([projectId, userId])
}

model Project {
  id                           Int                    @id @default(autoincrement())
  name                         String
  createdAt                    DateTime               @default(now())
  authorId                     Int?
  author                       User?                  @relation("author", fields: [authorId], references: [id], onDelete: SetNull)
  authorCanDelockObservations  Boolean                @default(false)
  ownerCanDelockObservations   Boolean                @default(false)
  storageLimit                 Int                    @default(1000000000)
  fields                       ProjectField[]
  dynamicFields                DynamicProjectField[]
  observations                 Observation[]
  contributors                 ProjectAccess[]
  invitations                  ProjectInvitation[]
  projectExports               ProjectExport[]
}

// TODO: ensure application knows that `choices` can be either String or String[] depending on db
model ProjectField {
  id                           Int                    @id @default(autoincrement())
  createdAt                    DateTime               @default(now())
  label                        String
  projectId                    Int
  project                      Project                @relation(fields: [projectId], references: [id], onDelete: Cascade)
  type                         String
  choices                      String?
  required                     Boolean                @default(false)
  index                        Int
  dynamicFields0s              DynamicProjectField[]  @relation("field0_id")
  dynamicFields1s              DynamicProjectField[]  @relation("field1_id")

  @@unique([projectId, index])
  @@unique([projectId, label])
}

// TODO: ensure application deletes dynamic fields using a project field that gets deleted
model DynamicProjectField {
  id                           Int                    @id @default(autoincrement())
  createdAt                    DateTime               @default(now())
  label                        String
  projectId                    Int
  project                      Project                @relation(fields: [projectId], references: [id], onUpdate: Cascade, onDelete: Cascade)
  operator                     String
  field0Id                     Int
  field1Id                     Int
  field0                       ProjectField           @relation("field0_id", fields: [field0Id], references: [id], onDelete: NoAction, onUpdate: NoAction)
  field1                       ProjectField           @relation("field1_id", fields: [field1Id], references: [id], onDelete: NoAction, onUpdate: NoAction)

  @@unique([field0Id, field1Id, operator])
}

// TODO: ensure this gets deleted when related project is deleted
model ProjectInvitation {
  id                           Int                    @id @default(autoincrement())
  inviterId                    Int
  projectId                    Int
  createdAt                    DateTime               @default(now())
  expiresAt                    DateTime
  emailHash                    String
  inviter                      User                   @relation("inviter", fields: [inviterId], references: [id], onDelete: NoAction, onUpdate: NoAction)
  project                      Project                @relation(fields: [projectId], references: [id], onDelete: Cascade)
}

// TODO: ensure observation is modified correctly when deleting author user
model Observation {
  id                           Int                    @id @default(autoincrement())
  createdAt                    DateTime               @default(now())
  updatedAt                    DateTime               @default(now())
  projectId                    Int
  project                      Project                @relation(fields: [projectId], references: [id], onDelete: Cascade, onUpdate: Cascade)
  userId                       Int?
  user                         User?                  @relation(fields: [userId], references: [id], onDelete: NoAction, onUpdate: NoAction)
  data                         String                 @default("{}")
  image                        ImageUpload?           @relation("observation_image")
  uploadInProgress             Boolean                @default(false)
  isDraft                      Boolean                @default(true)
  fileUploads                  FileUpload[]
}

model FileUpload {
  id                           Int                    @id @default(autoincrement())
  createdAt                    DateTime               @default(now())
  isS3                         Boolean
  filePath                     String                 @unique
  mimetype                     String
  originalName                 String
  observationId                Int
  observation                  Observation           @relation(fields: [observationId], references: [id], onDelete: Cascade)
}

model ImageUpload {
  id                           Int                    @id @default(autoincrement())
  createdAt                    DateTime               @default(now())
  isS3                         Boolean
  filePath                     String                 @unique
  mimetype                     String
  originalName                 String
  observationId                Int                    @unique
  observation                  Observation            @relation("observation_image", fields: [observationId], references: [id], onDelete: Cascade)
}

// TODO: ensure projectExports are modified correctly when removing related user or project
model ProjectExport {
  id                           Int                    @id @default(autoincrement())
  createdAt                    DateTime               @default(now())
  startDate                    DateTime
  endDate                      DateTime
  observationsCount            Int
  isS3                         Boolean
  filePath                     String                 @unique
  type                         String
  status                       String
  mimetype                     String
  error                        String?
  userId                       Int?
  size                         Int
  projectId                    Int
  user                         User?                  @relation(fields: [userId], references: [id], onDelete: NoAction, onUpdate: NoAction)
  project                      Project                @relation(fields: [projectId], references: [id], onDelete: Cascade, onUpdate: Cascade)
}
